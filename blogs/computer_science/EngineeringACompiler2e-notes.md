编译器设计 第二版 读书笔记 (Engineering A Compiler 2E)
====================

### 7.7 结构引用

结构体的定义中, 如果语言设计上允许用户控制结构布局, 则可能会因为目标体系结构特定的对齐规则而导致浪费一部分空间用于填充. 
相反, 如果语言不允许用户干涉结构布局, 则编译器可以设法(如改变字段顺序)优化布局以提高空间的利用率.
 
如果语言定义开发者可以直接获取结构数组的元素的地址, 需要按照内存连续的原则来分配空间. 如果不能直接通过内存地址访问元素, 则编译器可以将整个数组
当作单个结构来处理(比如 js). 两种方式, 在不同的外围代码访问方式下, 在具有高速缓存的系统上有较大的性能差异.

在 C 中, 用 malloc 的方式创建的结构, 只通过一个指针访问而没有一个固定的名字, 这种称为匿名值.   
这种指针的使用会限制编译器将值保存在寄存器中的能力. 因为编译器需要通过命名来确定是否命中缓存, 名字不可靠时, 只能采取保守策略.   
因此, 大量使用指针(包括数组)这种存在歧义可能性的方式会使效率降低. 相反, 在无歧义的局部值上进行计算就好多了.    
通过分析消除数组引用二义性要比消除指针引用二义性要简单.

### 7.8 控制流结构

基本程序快: 连续的无标号, 无控制流(分支和谓词)的代码块.  (谓词: predicate, 指布尔表达式)

控制流图(CFG): 节点表示基本程序块, 边表示基本块之间有可能发生的转移. CFG 可用于分析, 优化和代码生成过程. 实现控制流
的代码位于基本程序块中, 在每个块的末尾或末尾附近.

#### 7.8.1 条件执行

if-then-else 中, then/else 的代码块的长度会影响到编译器实现 if-then-else 结构时的策略. 如果代码块很简单, 编译器将尽可能
让谓词与底层硬件逻辑相匹配. 如果代码块很长, 这些代码的执行效率的重要程度将超过对谓词的求值, 此时应该避免使用处理器的谓词执行方式,
而采用传统的分支跳转方式.

对于处理器对分支的预测, 如果采用谓词执行方式的话, 会对 true/false 两种情况下的代码都预先执行, 再根据谓词的实际结果选择对应的那组
结果, 这是因为使用预测方式执行可以提高处理器超流水线的效率, 不会因为分支而使流水线出现一次排空.     
谓词执行比非谓词要节省进入分支的首个跳转和离开分支的跳转. 因此可以看出当代码块只有一两行的时候, 谓词执行还是很有优势的. 但代码一多起来,
谓词执行的代价就成倍增加.

对分支进行优化的时候需要考虑的几个问题: 

1. 各个分支预期执行频度
2. 各个分支的代码量差异
3. 分支内部的控制流复杂度

#### 7.8.2 循环和迭代

循环的初始化和循环体的每次执行, 都包含了分支. 编译器的预测应该是继续执行下一趟循环, 并且用循环体内的指令对分支延时槽进行填充.

对于循环体是基本程序块的情况, 编译器可以将每趟迭代的分支跳转从两个优化到一个, 但通常这不是非常必要.

while 循环的结构比 for 循环更加紧凑.

如果函数执行的最后一个操作是调用, 则该调用称为尾调用 (tail call). 如果调用的过程本身, 则称为尾递归. 
编译器通常会对尾调用进行特殊处理, 产生很高效的调用方式, 实现和迭代相同的效果.

#### 7.8.3 case 语句

case 的复杂性在于, 需要一种高效的方法来定位目标 case 子句. 常用方法有:

* 线性查找: 其本质就是一串连续的 if-then-else. 对于 case 数量小于 5 个的情况下, 这种方式比较高效.
* 直接计算地址: 对于 case 标签比较密集的情况(连续的整数), 可以直接使用跳转表或向量. 这样直接根据 expr 的值就可以直接计算出对应 case 的跳转地址.
 但如果所有 case 标签并不连续, 甚至很稀疏(比如差异较大的字符串), 就会导致该方案的效率大幅下降, 因为跳转表会变大, 但有效地址却很少.
* 二分查找: 对 case 标签规定一种顺序, 应用经典二分查找的思想实现对数级查找代价.

### 7.9 过程调用

一般来说, 将操作从调用前(precall)和返回后(postreturn)的部分移到被调用过程的起始(prologue)和收尾(epilogue)部分, 可以减少最终代码的总体大小.

#### 7.9.1 实参求值

