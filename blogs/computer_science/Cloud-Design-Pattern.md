Cloud Design Patterns
==========================

[原文](https://msdn.microsoft.com/en-us/library/dn568099.aspx)


[TOC]

## Cache-Aside 模式

**Read:**

> 1. 检查数据当前是否在缓存中
> 2. 如果数据不在缓存中, 则从数据库读取
> 3. 将数据的拷贝保存在缓存中

**Write: **

> 1. 如果数据不在缓存中,  直接写到数据库
> 2. 如果数据在缓存中, 则删除缓存中的数据拷贝.

#### 注意: 

* 缓存生命周期: 通常缓存数据会设置过期时间, 过长过短都会有问题. 缓存时间需要根据应用的数据访问模型来进行设置. 另外要注意, 缓存只在相对静态的数据或读显著高于写的情景下才能提高效率.
* 数据的淘汰(Evicting): 当缓存快满时, 需要将一些数据干掉以释放空间, 通常使用LRU算法, 也可以根据自己业务来自定义算法. 注意淘汰数据的时候最好综合考虑从数据库读取数据的成本和保留缓存数据的成本以及处理淘汰策略的成本.
* 预热(Priming): 在应用启动时将可能会访问到的数据提前加载到缓存, 以避免启动时服务和数据库的过载.
* 一致性风险: 虽然应用内的代码会尽量处理好一致性问题, 但难免出现遗漏, 以及从其他程序对数据库的修改. 尤其是当复制库之间进行频繁同步的时候, 可能会导致难以理解的一致性问题.
* 本地缓存: 使用本机内存作为缓存会在集群环境下带来一些不便. 不同节点间的缓存数据会快速出现大量不一致. 对数据快速过期只能缓解症状. 

#### 使用场景:

数据分布在一个较大的范围内(无法完全载入缓存), 并且实际数据需求难以预测, 因此将数据向缓存的加载推迟到数据将要被使用时.      
另外要注意, 对于web应用的会话信息不适用该模式.


## Circuit Breaker 模式

该模式用于在访问远端数据或服务时出现的临时性的失败或异常时进行控制.

简单使用 retry 反而会使得系统资源被迅速耗尽, 直至崩溃. 此时旧需要这种断路器模式了. 

该模式的本质是个状态机, 来模拟电路中的断路器. 它具有三种状态: 

* Closed: 闭合状态. 此时正常请求, 如果出现错误则记录次数, 当一段时间内的错误率达到一定阈值, 则变为 Open 状态, 同时启动一个 timeout 定时器, 当定时器结束后状态将自动变为 Half-Open 状态.

* Open: 此时会立刻返回收到的请求, 而不再执行请求对应的操作.

* Half-Open: 这种状态下会尝试以限定的速度(次数)来执行操作并响应请求, 如果这些操作都成功, 则变为 Closed 状态并重置 failure 计数器, 此时服务恢复; 如果其中任何一个失败, 则再次将状态变为 Open 并设置新的 timeout 计时器.

通过合理设置 Half-Open 状态, 可以避免故障恢复后出现瞬间负载过高导致再次超时或故障.  当 Half-Open 状态再次转为 Open 状态时, 也可以逐步增加 timeout 计时器的时间.  实践中 Open 状态可以返回异常, 也可以返回一个有意义的默认值.


#### 注意:

* 对于比较复杂的情况, 可以根据失败时的不同异常类型来进行不同程度的处理.
* 注意控制计时器的时间, 太长会导致故障恢复后无法尽快转换状态, 太短会导致频繁在 Open 和 Half-Open 状态之间切换.
* 可以在 Open 状态下使用心跳检测或 ping 的方式来帮助尽早探测到服务的恢复, 以减少等待时间.
* 对于可能会故障很久的情况, 采用管理员手动切换状态的方式也是一个办法.
* 很多情况下, 断路器都需要应付高并发的场景, 请确保断路器实现能正确处理并发请求, 另外, 注意不要引入过高的性能开销. 
* 注意远端不同数据源的区别对待, 以免混淆. 比如数据库的不同 replication.
* 某些情况下可以记录 Open 状态时的请求, 当状态正常后再重放这些请求.



## Compensating Transaction 模式

不知道是不是可以翻译成事务补偿模式.

应用所依赖并需要修改的数据通常并不在一个位置, 他们分布在不同的数据库, 机器, 机房, 城市. 实践中, 在这样的情况下去保证事务一致性是低效且不可取的. 事实上应该去保证最终一致性而不是事务一致性.

一系列相关操作的回滚不是简单的将数据恢复到操作之前, 而是需要考虑到在这期间的其他并发操作的影响, 考虑到各个步骤间可能完全异构的数据持久化方式, 考虑服务本身状态变化的回滚等许多复杂因素.

一般可以使用 workflow 的方式实现最终一致性操作. 记录每一步操作, 并且每一个步骤都有对应的撤销操作.     多个步骤的撤销操作有可能是同时进行, 并不一定是按照正向操作完全相反的顺序进行.

Compensating Transaction 本身也有可能会失败. 系统应该能够从未完全执行的"事务"中进行恢复并继续执行. 这个过程中有可能需要重复执行上次失败的操作, 因此, 最好将所有的操作都设计为 idempotency (幂等)的. 另外有时可能某些异常或失败需要人工干预, 这时应该尽量保留关键业务中尽可能的各种信息以备审阅.

#### 注意:

* 有时候, 某个有问题的步骤并没有立即返回失败, 而是被阻塞了. 这个时候需要用超时机制来解决.
* 补偿逻辑都是强业务相关的, 因此它以赖于步骤执行中是否可以提供充分的信息用来进行操作的撤销.
* 执行事务逻辑的部分需要能快速从故障中恢复, 并完整的保留上次处理时的断点信息, 用来从故障中准确的恢复事务的处理.
* 对于一次操作中所要使用的所有数据加一个时间较短的超时锁, 并在操作开始前先获取他们, 这样可以提高整体的操作成功率. 操作必须在获取到本次执行所需的所有数据后才开始, 必须在超时锁到期前结束才算完成.
* 可以与重试模式结合, 在操作 fail 或异常后先重试, 再重试无法完成的情况下在进行事务的撤销.


## Compensating Transaction 模式


1. 多应用程序(生产者)接收用户的请求, 将其封装为消息, 送到消息队列中.
2. 多个后台服务程序(消费者)从队列中读取消息, 并对其进行处理.

#### 作用与优点

* 用于处理大量的请求(异步地), 业务逻辑处理过程中, 不会阻塞其他请求的处理.
* 可以应付突发的大量请求, 消息队列可以作为一个 buffer. 
* 提高了服务的整体可靠性.
* 消费者之间不需要太复杂的协调处理
* 可扩展性, 易扩展性
* 消息队列可以改造成支持事务的方式, 当消费者处理失败后可以重新放入队列被其他实例处理.

#### 注意

1. 需要注意负载的均衡性, 以免个别实例成为系统瓶颈
2. 恰当处理消息的顺序. 将消息设计成具有幂等性质的, 以消除系统对消息的顺序的依赖.
3. 需要检测并处理有问题的消息. 以免出现循环重试.
4. 如果后台服务(消费者)完成了对消息的处理并生成了结果, 并且需要将这个结果返回给应用程序(生产者). 那么需要将结果保存在一个地方(可以被应用程序访问到), 并设法通知应用程序该消息已处理完成, 让它去指定位置取出结果即可. 
5. 当系统规模很大时, 单个消息队列会成为瓶颈. 可以考虑将生产者和消费者分成多个区, 每个区有一个消息队列, 也可以不分区, 而采用负载均衡的方式向多个消息队列分发消息.
6. 消息队列本身需要保证可靠性, 即所有收到的消息至少需要被发送一次.

#### 使用场景

1. 业务逻辑可以被拆分成若干可异步执行的任务.
2. 任务之间无依赖, 可以并行执行

PS:

**PeekLock** : 也称非破坏性读. 从消息队列读取消息时并不直接删除, 而仅将它对其他消费者隐藏. 首个消费者如果成功处理完成该消息, 会主动将它送消息队列中删除, 如果失败, 则 peeklock 会超时, 并将该消息重新置为可见状态.







## Compute Resource Consolidation 模式

有时针对一个应用或服务, 我们会将其中的每个小的计算过程拆分成独立的计算单元, 这样可以简化复杂业务逻辑的设计, 但是同时也增加了整个系统的运行开销
