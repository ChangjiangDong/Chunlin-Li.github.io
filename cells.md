
## 2016-09-10

### Linux shell 和 fork() wait() exec() 的关系

Linux shell 也是一个程序, 当在 shell 中输入命令执行程序的时候, shell 首先会先 fork() 出一个新的进程, 此时新的进程和之前的 shell 进程完全一样, 
因为是 fork() 相当于是完全复制了一个进程, 包括当前所执行的位置。 但是父进程也就是最初的 shell 进程中和子进程中的 fork() 调用返回值是不同的,
根据这一点, 可以在程序中给新 fork() 出来的进程以特殊的安排。 这个新的进程要做的事情也很简单, 直接调用 exec() 系统调用来执行 shell 中刚才输入
的命令, 而 exec() 事实上从指定位置载入了新的程序二进制文件, 并完全覆盖当前进程的状态, 抹杀当前进程在此之前的执行痕迹(内存和寄存器等), 就好像
exec() 所执行的命令是在一个全新的环境中开始执行的一样。  至此, 子进程已经开始执行 shell 中输入的目标指令了, 而之前的父进程 shell, 在 fork()
后就直接调用 wait() 系统调用进入了 sleep 状态, 等待子进程执行结束后才会再次被唤醒, 然后现实命令行提示符, 等待下一条命令的输入。 

